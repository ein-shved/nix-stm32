# STM 32 Nix Builder

This is generalized helper for projects based on STM32 microcontrollers and
nix-based builders. It assumes, you use st-link programmer and Stm32Cube HAL
lib.

## Flake

Use mkFirmware function in your flake.nix file like next:

```nix
{
  inputs = {
    stm32.url = github:ein-shved/nix-stm32;
  };
  outputs = { self, stm32, ... } :
  stm32.mkFirmware {
    name = "my-stm32-project";
    src = ./.;
    mcu = stm32.mcus.stm32f103;
  };
}
```

### MCU

The `nix-stm32` flake outputs the set of MCU Lines descriptors in `mcus`
outputs. Each descriptor may has next fields:

* `cubeLib` - the path to `STM32Cube` HAL library;

* `firmwareStart` - the address of firmware start (the stringified constant).

There next descriptors described withing `mcus` output:

* `stm32f{1..4}` - the several supported of stm32fxxx lines. Each of them uses
  STMicroelectronics/STM32CubeFX as `cubeLib` field and do not define the
  `firmwareStart` field;

* `stm32f103` - the concrete stm32f103 mcu (mostly for bluepill board) with
  `firmwareStart` equals to `0x8000000`.

### mkFirmware

The function `mkFirmwre` produces the set of package for each default system:

* `firmware` - the target derivation with `firmware` folder to which placed all
  `*.elf` and `*.bin` files produced inside `buildDir`;

* `flasher` - the script which runs `st-flash` to flash `*.bin` firmware file
  found withing `buildDir` directory. You can call the script with another path
  where to search for firmware file;

* `productFlasher` - the same as `flasher` but used produced by `firmware`
  derivation `*.bin` file by default;

* `debugger` - the scripts which runs `st-util` with gdb server in background
  and attaches the gdb shell to it with `*.elf` found withing `buildDir`
  directory. You can call the script with another path where to search for
  firmware file;

* `productDebugger` - the same as `debugger` but used produced by `firmware`
  derivation `*.elf` file by default;

* `format` - the script with applies `clang-format` for all source files in
  current (or passed with argument) dirrectory. If the directory contains
  `.clang-format` or `_clang-format` - it will be used, in other case the one
  close to `stm32CubeMX` will be used (see
  [clang-format.yaml](clang-format.yaml)).

* `fixMakefile` - the utility which replaces absolute paths withing Makefile to
  variable-based, removes duplicates of sources and extra carriage-return
  symbols;

* `fixGen` - the combination of `format` and `fixMakefile`. Run it to fix style
  in auto-generated by Stm32CubeMx files;

* `scripts` - a join of `flasher`, `debugger` and `format` derivations;

* `productScripts` - a join of `productFlasher` and `productDebugger`
  derivations;

* `all` - a join of `productFlasher`, `productDebugger` and `firmware`
  derivations.

The function `mkFirmware` accepts the set of arguments same to `mkDerivation`
function and additionally next:

* `mcu` - the describer for [MCU](#MCU)

* `stm32CubeLibVarName` - the name of environment variable of HAL library to
  define for builder (`STM32CUBE_PATH` by default)

* `buildDir` - the relative path to build directory (`build` by default)

### mkRustFirmware

The function `mkRustFirmwre` produces the flake-ideomatic tree for firmware,
built with rust.

It accepts the same set of attributes as buildRustPackage, and additional:

* `mcu` - the describer for [MCU](#MCU)

It requires from rust project to be ready to be built for embedded:

* have a correct `build.rs` file

* have a correct `.cargo/config.toml` file

* have a correct `memory.x` file

### mergeFirmwares

The function `mergeFirmwares` allows to merge several flake trees (produced by
`mkFirmware` or `mkRustFirmware`) to the single tree.

It accepts an attrset the value of each attribute expected to be the flake-tree.
The function takes the `default` packages apps and devShells from each and
places them to result with the name of corresponding tree.

If you provides the tree with name `default` its parts became the default.

## Usage

Say, you used nix-stm32 shown [above](#Flake). Then you may use work with your
flake in several ways:

### Final product

```bash
$ nix build           #To build firmware
$ nix run             #To upload the firmware to board
```

### Developing the C Project with CubeMX

```bash
$ nix develop         # To run development shell
$ stm32cubemx         # Run Stm32CubeMx, configure project and generate
                      # code with it. Almost all your files will change.
$ fixGen              # Bring the style of your files back to normal.
                      # There only significant changes will be visible
                      # withing git status
$ make -j8            # To build the intermidiate firmware
$ flasher             # To flash the firmware from current build
                      # dirictory
$ debug               # To connect to board with gdb
```

### Developing the Rust Project

```bash
$ nix develop         # To run development shell
$ cargo build         # To build the firmware
$ cargo run           # To flash the firmware from current build and debug it
```
